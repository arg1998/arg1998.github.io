(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[877],{17879:(e,t,a)=>{(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/stateful-cpp-part-1",function(){return a(35774)}])},76251:(e,t,a)=>{"use strict";a.d(t,{A:()=>r});var o=a(74848),n=a(88806),s=a(3329);let r=e=>{let{postData:t,bannerImage:a="",bannerImageMaxHeight:r=null,bannerImagePosition:i={x:.5,y:.5},bannerImageStyles:l={},drawBottomSeparator:c=!1}=e;return(0,o.jsxs)("div",{id:"blog-post-banner-container",children:[(0,o.jsxs)("a",{className:"blog-post-back-btn",href:"/blog",children:[(0,o.jsx)("i",{className:"bi bi-arrow-left"})," Back to Blog"]}),(0,o.jsx)("h1",{className:"title",children:t.fancyTitle}),(0,o.jsxs)("div",{className:"blog-post-tag-date-container",children:[(0,o.jsx)("span",{className:"blog-post-banner-date",children:(0,s.Y)(new Date(t.date))}),(0,o.jsx)("div",{style:{display:"flex"},children:t.tags&&Object.values(t.tags).length>0&&(0,o.jsx)("div",{children:t.tags.map((e,t)=>{let a=n.A[e];return a?(0,o.jsx)("span",{className:"single-post-tag",children:a.label},t):null})})})]}),a&&(0,o.jsx)("img",{className:"blog-post-banner-image",src:a,alt:t.fancyTitle,style:{maxHeight:r||null,objectPosition:"".concat(100*i.x,"% ").concat(100*i.y,"%"),...l}}),c&&(0,o.jsx)("hr",{})]})}},21833:(e,t,a)=>{"use strict";a.d(t,{A:()=>n});var o=a(74848);let n=e=>{let{children:t}=e;return(0,o.jsx)("div",{id:"blog-post-vertical-container",children:t})}},46081:(e,t,a)=>{"use strict";a.d(t,{A:()=>d});var o=a(74848),n=a(3441),s=a(7776),r=a(46800),i=a(24967),l=a(18183),c=a(49752),h=a(29212),u=a(9012),p=a(75651);a(34811),a(73736);let d=e=>{let{MarkdownFileContent:t,styles:a,numberedHeadings:d=!1}=e;return d&&remarkPlugins.push(remarkNumberedHeadings),(0,o.jsx)("div",{className:"blog-container-md",style:a,children:(0,o.jsx)(n.oz,{remarkPlugins:[r.A,l.A,s.A,i.A],rehypePlugins:[h.A,c.A,p.A,u.A],children:t})})}},11987:(e,t,a)=>{"use strict";a.d(t,{A:()=>d});var o=a(74848),n=a(50756),s=a(15943),r=a(18185),i=a(7619),l=a.n(i),c=a(9012),h=a(77088),u=a(46800);let p=function(e){let t=!(arguments.length>1)||void 0===arguments[1]||arguments[1],a=Math.floor(Math.random()*(99999e7+1))+1e7;e.push("\n".concat(a));let o=(0,n.l)().use(u.A).use(s.A).use(r.A);return t&&(o=o.use(c.A)),o.use(l(),{position:"beforeend"}).use(h.A).processSync(e.join("\n")).toString().split("<p>".concat(a,"</p>"))[1]||""},d=e=>{let{markdownContents:t=null,showHeader:a,styles:n,generateReference:s=!0}=e;if(null==t||!t.length)return null;let r=p(t,s);return r?(0,o.jsxs)(o.Fragment,{children:[a&&(0,o.jsx)("h1",{children:"Contents"}),(0,o.jsx)("div",{className:"blog-post-toc-container ".concat(!s&&"toc-disabled-links"),dangerouslySetInnerHTML:{__html:r},style:n})]}):null}},88806:(e,t,a)=>{"use strict";a.d(t,{A:()=>o});let o={all:{value:"all",label:"All Tags"},cpp:{value:"cpp",label:"C++"},ezego:{value:"ezego",label:"eZeGo"},web_dev:{value:"web_dev",label:"Web Dev"},nextjs:{value:"nextjs",label:"NextJs"},performance:{value:"performance",label:"Performance"},devJounral:{value:"devJounral",label:"Dev Journal"},poetry:{value:"poetry",label:"Poetry"}}},35774:(e,t,a)=>{"use strict";a.r(t),a.d(t,{__N_SSG:()=>p,default:()=>d});var o=a(74848),n=a(86715),s=a(96540),r=a(2504),i=a(21833),l=a(76251),c=a(11987),h=a(46081);let u='> [!info]\r\n> ### _**TL; DR;**_\r\n> We are trying to build a state manager in C++ to enable our program to track users actions and perform undo/redo operations when requested. \r\n\r\n# Introduction\r\n\r\nModern softwares, especially the ones with **G**raphical **U**ser **I**nterface (GUIs), incorporate a lot of features, many of which are unique to the types of problems they are trying to solve. However, one and often very important feature of most softwares is **state management**. Ultimately, a software (or a program in general sense) is nothing but a gigantic set of functions that transform one form of data to another upon user actions or other system events. Any software with even minimal complexity, has tons of states. For example, the logic for opening a pop-up window and asking user to select a theme is tracking two different states, conceptually speaking: Is the the pop-up window open and the value for chosen theme.  As a matter of fact, these two states corresponds to at least two variables within the code. \r\n\r\nNow if you go back to your favorite GUI applications, you can see (hopefully) that all of them have a method for tracking your actions inside the software . This "Action Tracking" mechanism is what allows you to tell the application to **Undo** what you have just done! The famous `Ctrl + Z` that reverts your actions in time! The opposite is **Redo** where you tell the program to basically, well, redo you actions. A state manager\'s job is to track such state changes in the program and store a snapshot of the software before you commit an action. And when you change your mind, the state manager will bring back the latest snapshot upt to a particular point in time or a certain number of actions. \r\n\r\n\r\nHowever, an important concept when dealing with application states, is the separation of logic states and action states. Although one could argue for a different form of state separation, but I would like to stick with this one mainly because of the nature of the software we will be working on in the next few articles. But what do these logic vs action state categories mean? \r\n\r\n#### Action States\r\nActions states are the type of data that a user directly and intentionally changes and expect the program to remember those decisions. I know this not a clear definitions, but lets work it through intuition. In the theme pop-up window, we present the user with a list of 100 themes in a combobox. Our lovely user is selecting various themes and seeing them applied to the application in real-time. So far the user has chosen 5 themes from the list, but they are not happy with their current selection. They kind of liked the third theme, or some theme in the middle but they forgot the name and it is a huge list to go through. This example perfectly captures the need for a state manager, tracking the user\'s choice for theme so when they change their mind, they can revert back the state of the combobox. We call the variable that tracks the selected theme an action state. All action states are tracked by a state manager \r\n\r\n\r\n#### Logic State\r\nLogic states dictate and track the behavior of the software, but unlike action states, the state manager does not track their changes. In our previous example, when the user clicks a button to change the theme of the application, a pop-up window shows up on the screen. Whether to display this pop-up or not is tracked by a `bool` variable. Set it to `true` and the program will show the pop-up and set it to `false` to close it. By design, this type of state change does not need to be tracked by our state manager since we (and by certain extension, the user) don\'t want to undo/redo the opening and closing of a pop-up window behavior. The opening/closing behavior of the pop-up window is only achieved through real-time interactions and not recorded actions by a state manager! \r\n\r\n\r\n# Goals\r\nI am developing this system as a part of my on-going passion project <a href="https://argosta.me/projects/#ezego" target="_blank">eZeGo</a>\r\nBefore we start implementing, lets discuss some of the goals and expected behavior I want from a state manager for my software. \r\n';var p=!0;let d=e=>{let{postData:t,socialPreviewData:a}=e;if(!t.active){let e=(0,n.useRouter)();return(0,s.useEffect)(()=>{e.replace("/404")},[]),null}return(0,o.jsx)(r.A,{currentRoute:t.URI,pageTitle:t.fancyTitle,pagePreviewData:a,children:(0,o.jsxs)(i.A,{children:[(0,o.jsx)(l.A,{postData:t,bannerImage:t.URI+"/banner.jpg"}),(0,o.jsx)(c.A,{markdownContents:[u],showHeader:!0,generateReference:!0}),(0,o.jsx)(h.A,{MarkdownFileContent:u})]})})}},3329:(e,t,a)=>{"use strict";a.d(t,{Y:()=>o});let o=e=>e.toLocaleDateString("en-US",{year:"numeric",month:"long",day:"numeric"})}},e=>{var t=t=>e(e.s=t);e.O(0,[611,111,617,272,504,636,593,792],()=>t(17879)),_N_E=e.O()}]);